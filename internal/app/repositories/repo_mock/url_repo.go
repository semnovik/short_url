package repo_mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i short_url/internal/app/repositories.URLRepo -o ./mocks_repos/url_repo.go -n URLRepoMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// URLRepoMock implements repositories.URLRepo
type URLRepoMock struct {
	t minimock.Tester

	funcAdd          func(url string) (uuid string)
	inspectFuncAdd   func(url string)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mURLRepoMockAdd

	funcGet          func(uuid string) (url string, err error)
	inspectFuncGet   func(uuid string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mURLRepoMockGet
}

// NewURLRepoMock returns a mock for repositories.URLRepo
func NewURLRepoMock(t minimock.Tester) *URLRepoMock {
	m := &URLRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mURLRepoMockAdd{mock: m}
	m.AddMock.callArgs = []*URLRepoMockAddParams{}

	m.GetMock = mURLRepoMockGet{mock: m}
	m.GetMock.callArgs = []*URLRepoMockGetParams{}

	return m
}

type mURLRepoMockAdd struct {
	mock               *URLRepoMock
	defaultExpectation *URLRepoMockAddExpectation
	expectations       []*URLRepoMockAddExpectation

	callArgs []*URLRepoMockAddParams
	mutex    sync.RWMutex
}

// URLRepoMockAddExpectation specifies expectation struct of the URLRepo.Add
type URLRepoMockAddExpectation struct {
	mock    *URLRepoMock
	params  *URLRepoMockAddParams
	results *URLRepoMockAddResults
	Counter uint64
}

// URLRepoMockAddParams contains parameters of the URLRepo.Add
type URLRepoMockAddParams struct {
	url string
}

// URLRepoMockAddResults contains results of the URLRepo.Add
type URLRepoMockAddResults struct {
	uuid string
}

// Expect sets up expected params for URLRepo.Add
func (mmAdd *mURLRepoMockAdd) Expect(url string) *mURLRepoMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("URLRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &URLRepoMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &URLRepoMockAddParams{url}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the URLRepo.Add
func (mmAdd *mURLRepoMockAdd) Inspect(f func(url string)) *mURLRepoMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for URLRepoMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by URLRepo.Add
func (mmAdd *mURLRepoMockAdd) Return(uuid string) *URLRepoMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("URLRepoMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &URLRepoMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &URLRepoMockAddResults{uuid}
	return mmAdd.mock
}

// Set uses given function f to mock the URLRepo.Add method
func (mmAdd *mURLRepoMockAdd) Set(f func(url string) (uuid string)) *URLRepoMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the URLRepo.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the URLRepo.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the URLRepo.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mURLRepoMockAdd) When(url string) *URLRepoMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("URLRepoMock.Add mock is already set by Set")
	}

	expectation := &URLRepoMockAddExpectation{
		mock:   mmAdd.mock,
		params: &URLRepoMockAddParams{url},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up URLRepo.Add return parameters for the expectation previously defined by the When method
func (e *URLRepoMockAddExpectation) Then(uuid string) *URLRepoMock {
	e.results = &URLRepoMockAddResults{uuid}
	return e.mock
}

// Add implements repositories.URLRepo
func (mmAdd *URLRepoMock) Add(url string) (uuid string) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(url)
	}

	mm_params := &URLRepoMockAddParams{url}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uuid
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := URLRepoMockAddParams{url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("URLRepoMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the URLRepoMock.Add")
		}
		return mm_results.uuid
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(url)
	}
	mmAdd.t.Fatalf("Unexpected call to URLRepoMock.Add. %v", url)
	return
}

// AddAfterCounter returns a count of finished URLRepoMock.Add invocations
func (mmAdd *URLRepoMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of URLRepoMock.Add invocations
func (mmAdd *URLRepoMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to URLRepoMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mURLRepoMockAdd) Calls() []*URLRepoMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*URLRepoMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *URLRepoMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *URLRepoMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLRepoMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLRepoMock.Add")
		} else {
			m.t.Errorf("Expected call to URLRepoMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to URLRepoMock.Add")
	}
}

type mURLRepoMockGet struct {
	mock               *URLRepoMock
	defaultExpectation *URLRepoMockGetExpectation
	expectations       []*URLRepoMockGetExpectation

	callArgs []*URLRepoMockGetParams
	mutex    sync.RWMutex
}

// URLRepoMockGetExpectation specifies expectation struct of the URLRepo.Get
type URLRepoMockGetExpectation struct {
	mock    *URLRepoMock
	params  *URLRepoMockGetParams
	results *URLRepoMockGetResults
	Counter uint64
}

// URLRepoMockGetParams contains parameters of the URLRepo.Get
type URLRepoMockGetParams struct {
	uuid string
}

// URLRepoMockGetResults contains results of the URLRepo.Get
type URLRepoMockGetResults struct {
	url string
	err error
}

// Expect sets up expected params for URLRepo.Get
func (mmGet *mURLRepoMockGet) Expect(uuid string) *mURLRepoMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLRepoMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &URLRepoMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &URLRepoMockGetParams{uuid}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the URLRepo.Get
func (mmGet *mURLRepoMockGet) Inspect(f func(uuid string)) *mURLRepoMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for URLRepoMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by URLRepo.Get
func (mmGet *mURLRepoMockGet) Return(url string, err error) *URLRepoMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLRepoMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &URLRepoMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &URLRepoMockGetResults{url, err}
	return mmGet.mock
}

// Set uses given function f to mock the URLRepo.Get method
func (mmGet *mURLRepoMockGet) Set(f func(uuid string) (url string, err error)) *URLRepoMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the URLRepo.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the URLRepo.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the URLRepo.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mURLRepoMockGet) When(uuid string) *URLRepoMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("URLRepoMock.Get mock is already set by Set")
	}

	expectation := &URLRepoMockGetExpectation{
		mock:   mmGet.mock,
		params: &URLRepoMockGetParams{uuid},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up URLRepo.Get return parameters for the expectation previously defined by the When method
func (e *URLRepoMockGetExpectation) Then(url string, err error) *URLRepoMock {
	e.results = &URLRepoMockGetResults{url, err}
	return e.mock
}

// Get implements repositories.URLRepo
func (mmGet *URLRepoMock) Get(uuid string) (url string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(uuid)
	}

	mm_params := &URLRepoMockGetParams{uuid}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.url, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := URLRepoMockGetParams{uuid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("URLRepoMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the URLRepoMock.Get")
		}
		return mm_results.url, mm_results.err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(uuid)
	}
	mmGet.t.Fatalf("Unexpected call to URLRepoMock.Get. %v", uuid)
	return
}

// GetAfterCounter returns a count of finished URLRepoMock.Get invocations
func (mmGet *URLRepoMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of URLRepoMock.Get invocations
func (mmGet *URLRepoMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to URLRepoMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mURLRepoMockGet) Calls() []*URLRepoMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*URLRepoMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *URLRepoMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *URLRepoMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLRepoMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLRepoMock.Get")
		} else {
			m.t.Errorf("Expected call to URLRepoMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to URLRepoMock.Get")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *URLRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockGetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *URLRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *URLRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockGetDone()
}
